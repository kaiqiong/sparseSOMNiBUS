// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppArmadillo.h>
#include <Rcpp.h>

using namespace Rcpp;

// getSeparateThetaCpp
List getSeparateThetaCpp(const NumericVector& theta, const int& nk, const int& numCovs);
RcppExport SEXP _sparseSOMNiBUS_getSeparateThetaCpp(SEXP thetaSEXP, SEXP nkSEXP, SEXP numCovsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericVector& >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< const int& >::type nk(nkSEXP);
    Rcpp::traits::input_parameter< const int& >::type numCovs(numCovsSEXP);
    rcpp_result_gen = Rcpp::wrap(getSeparateThetaCpp(theta, nk, numCovs));
    return rcpp_result_gen;
END_RCPP
}
// binomObjectCppLossOnly
//'@title estimatePijCpp  //'@description return a vector of pi_ij   //estimatePijCpp +  binomObjectCpp   List binomObjectCppLossOnly(const List& thetaSep, const arma::mat& basisMat0, const List& designMat1, const int& numCovs, const bool& truncation, const arma::vec& meth, const arma::vec& unmeth);
RcppExport SEXP _sparseSOMNiBUS_binomObjectCppLossOnly(SEXP thetaSepSEXP, SEXP basisMat0SEXP, SEXP designMat1SEXP, SEXP numCovsSEXP, SEXP truncationSEXP, SEXP methSEXP, SEXP unmethSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const List& >::type thetaSep(thetaSepSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type basisMat0(basisMat0SEXP);
    Rcpp::traits::input_parameter< const List& >::type designMat1(designMat1SEXP);
    Rcpp::traits::input_parameter< const int& >::type numCovs(numCovsSEXP);
    Rcpp::traits::input_parameter< const bool& >::type truncation(truncationSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type meth(methSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type unmeth(unmethSEXP);
    rcpp_result_gen = Rcpp::wrap(binomObjectCppLossOnly(thetaSep, basisMat0, designMat1, numCovs, truncation, meth, unmeth));
    return rcpp_result_gen;
END_RCPP
}
// binomObjectCppLossOnlyVec
List binomObjectCppLossOnlyVec(const NumericVector& theta, const arma::mat& basisMat0, const int& numCovs, const List& designMat1, const bool& truncation, const arma::vec& meth, const arma::vec& unmeth, const arma::vec& total, const int& nk);
RcppExport SEXP _sparseSOMNiBUS_binomObjectCppLossOnlyVec(SEXP thetaSEXP, SEXP basisMat0SEXP, SEXP numCovsSEXP, SEXP designMat1SEXP, SEXP truncationSEXP, SEXP methSEXP, SEXP unmethSEXP, SEXP totalSEXP, SEXP nkSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericVector& >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type basisMat0(basisMat0SEXP);
    Rcpp::traits::input_parameter< const int& >::type numCovs(numCovsSEXP);
    Rcpp::traits::input_parameter< const List& >::type designMat1(designMat1SEXP);
    Rcpp::traits::input_parameter< const bool& >::type truncation(truncationSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type meth(methSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type unmeth(unmethSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type total(totalSEXP);
    Rcpp::traits::input_parameter< const int& >::type nk(nkSEXP);
    rcpp_result_gen = Rcpp::wrap(binomObjectCppLossOnlyVec(theta, basisMat0, numCovs, designMat1, truncation, meth, unmeth, total, nk));
    return rcpp_result_gen;
END_RCPP
}
// gbinomObjectCpp
NumericVector gbinomObjectCpp(const arma::vec& pi_ij_arma, const arma::mat& basisMat0, const arma::vec& meth, const arma::vec& total, const int& nk, const int& numCovs, const List& designMat1);
RcppExport SEXP _sparseSOMNiBUS_gbinomObjectCpp(SEXP pi_ij_armaSEXP, SEXP basisMat0SEXP, SEXP methSEXP, SEXP totalSEXP, SEXP nkSEXP, SEXP numCovsSEXP, SEXP designMat1SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type pi_ij_arma(pi_ij_armaSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type basisMat0(basisMat0SEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type meth(methSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type total(totalSEXP);
    Rcpp::traits::input_parameter< const int& >::type nk(nkSEXP);
    Rcpp::traits::input_parameter< const int& >::type numCovs(numCovsSEXP);
    Rcpp::traits::input_parameter< const List& >::type designMat1(designMat1SEXP);
    rcpp_result_gen = Rcpp::wrap(gbinomObjectCpp(pi_ij_arma, basisMat0, meth, total, nk, numCovs, designMat1));
    return rcpp_result_gen;
END_RCPP
}
// fitProxGradCppClean1
//'@title fitProxGradCpp //'@description use proximial gradient descent with backtracking line search to minimize //'a penalized negative binomial likelihood with a group LASSO penalty. This function is //'for the tilda version of our objective function. So matrix Hp is not needed //'@name fitProxGradCpp //'@param theta the initial value for theta tilda //'@param intStepSize the initial step size used //'@param lambda1 the penalty parameter lambda in our paper //'@param dat data frame with two columns named as "Meth_Counts" and "Total_Counts" //'@param basisMat0 design matrix for the intercept. Its row equals to the row of dat //'@param nk number of knots used for the covariate --- currently it is the same for all List fitProxGradCppClean1(NumericVector& theta, double& intStepSize, const double& lambda1, const arma::vec& meth, const arma::vec& unmeth, const arma::vec& total, const arma::mat& basisMat0, const int& nk, const double& maxInt, const double& epsilon, const double& shrinkScale, const bool& accelrt, const int& numCovs, const List& designMat1, const bool& truncation);
RcppExport SEXP _sparseSOMNiBUS_fitProxGradCppClean1(SEXP thetaSEXP, SEXP intStepSizeSEXP, SEXP lambda1SEXP, SEXP methSEXP, SEXP unmethSEXP, SEXP totalSEXP, SEXP basisMat0SEXP, SEXP nkSEXP, SEXP maxIntSEXP, SEXP epsilonSEXP, SEXP shrinkScaleSEXP, SEXP accelrtSEXP, SEXP numCovsSEXP, SEXP designMat1SEXP, SEXP truncationSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector& >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< double& >::type intStepSize(intStepSizeSEXP);
    Rcpp::traits::input_parameter< const double& >::type lambda1(lambda1SEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type meth(methSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type unmeth(unmethSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type total(totalSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type basisMat0(basisMat0SEXP);
    Rcpp::traits::input_parameter< const int& >::type nk(nkSEXP);
    Rcpp::traits::input_parameter< const double& >::type maxInt(maxIntSEXP);
    Rcpp::traits::input_parameter< const double& >::type epsilon(epsilonSEXP);
    Rcpp::traits::input_parameter< const double& >::type shrinkScale(shrinkScaleSEXP);
    Rcpp::traits::input_parameter< const bool& >::type accelrt(accelrtSEXP);
    Rcpp::traits::input_parameter< const int& >::type numCovs(numCovsSEXP);
    Rcpp::traits::input_parameter< const List& >::type designMat1(designMat1SEXP);
    Rcpp::traits::input_parameter< const bool& >::type truncation(truncationSEXP);
    rcpp_result_gen = Rcpp::wrap(fitProxGradCppClean1(theta, intStepSize, lambda1, meth, unmeth, total, basisMat0, nk, maxInt, epsilon, shrinkScale, accelrt, numCovs, designMat1, truncation));
    return rcpp_result_gen;
END_RCPP
}
// sparseOmegaCr
arma::mat sparseOmegaCr(const arma::vec& myh, const int& K, const arma::mat& matF);
RcppExport SEXP _sparseSOMNiBUS_sparseOmegaCr(SEXP myhSEXP, SEXP KSEXP, SEXP matFSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type myh(myhSEXP);
    Rcpp::traits::input_parameter< const int& >::type K(KSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type matF(matFSEXP);
    rcpp_result_gen = Rcpp::wrap(sparseOmegaCr(myh, K, matF));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_sparseSOMNiBUS_getSeparateThetaCpp", (DL_FUNC) &_sparseSOMNiBUS_getSeparateThetaCpp, 3},
    {"_sparseSOMNiBUS_binomObjectCppLossOnly", (DL_FUNC) &_sparseSOMNiBUS_binomObjectCppLossOnly, 7},
    {"_sparseSOMNiBUS_binomObjectCppLossOnlyVec", (DL_FUNC) &_sparseSOMNiBUS_binomObjectCppLossOnlyVec, 9},
    {"_sparseSOMNiBUS_gbinomObjectCpp", (DL_FUNC) &_sparseSOMNiBUS_gbinomObjectCpp, 7},
    {"_sparseSOMNiBUS_fitProxGradCppClean1", (DL_FUNC) &_sparseSOMNiBUS_fitProxGradCppClean1, 15},
    {"_sparseSOMNiBUS_sparseOmegaCr", (DL_FUNC) &_sparseSOMNiBUS_sparseOmegaCr, 3},
    {NULL, NULL, 0}
};

RcppExport void R_init_sparseSOMNiBUS(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
